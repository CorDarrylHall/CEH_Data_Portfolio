<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.313">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sleep and Employment: Predicting Job Classification through Data Analytics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">
 <span class="menu-text">CorDarryl E. Hall</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../Services.html">
 <span class="menu-text">Services</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../index.html">
 <span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"><i class="bi bi-twitter" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
  <li class="nav-item dropdown  compact">
    <a class="nav-link dropdown-toggle" href="#" id="" role="button" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text"></span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="">    
        <li>
    <a class="dropdown-item" href="https://c1fbaz-cordarryl-hall.shinyapps.io/posts/">
 <span class="dropdown-text">Fertility Rate</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://c1fbaz-cordarryl-hall.shinyapps.io/posts/">
 <span class="dropdown-text">Income</span></a>
  </li>  
    </ul>
  </li>
</ul>
              <div class="quarto-toggle-container">
                  <a href="" class="quarto-color-scheme-toggle nav-link" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
              </div>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Sleep and Employment: Predicting Job Classification through Data Analytics</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Python</div>
                <div class="quarto-category">Data Analysis</div>
                <div class="quarto-category">Data Science</div>
                <div class="quarto-category">Data Visualization</div>
                <div class="quarto-category">Trend Analysis</div>
                <div class="quarto-category">Machine Learning</div>
                <div class="quarto-category">Random Forest Classification</div>
                <div class="quarto-category">SVM Classifier</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<style>
body {
  font-family: 'Times New Roman', sans-serif;
  background-color: #f9f9f9;
  color: #333;
}

h1, h2, h3, h4, h5, h6 {
  color: #999;
}

nav {
  background: url("https://www.shutterstock.com/shutterstock/videos/1069623523/preview/stock-footage-melbourne-australia-mar-motorized-moving-shot-of-new-albums-released-in-spotify-app.mp4") no-repeat top center fixed;
  background-size: cover;
  height: 20vh;
  width: 100%;
}

.panel-tabset {
  border: 1px solid #ddd;
  border-radius: 5px;
  background-color: #fff;
  padding: 15px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.panel-tabset h3 {
  margin-top: 0;
}

.panel-tabset .tab-content {
  padding: 10px 0;
}
</style>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>This study aims to predict job roles accurately by analyzing the relationship between sleep patterns, job classification, and other relevant factors. By utilizing sleep-related data and demographics in a model, the researchers seek to optimize workforce planning and develop personalized workplace strategies</p>
</section>
<section id="problem-statement" class="level2">
<h2 class="anchored" data-anchor-id="problem-statement">Problem Statement</h2>
<p>The research aims to improve human resource management strategies and personalized workplace interventions by accurately predicting job classifications through the analysis of sleep patterns and other health-related factors, exploring the relationship between sleep, stress, and job characteristics.</p>
</section>
<section id="research-questions" class="level2">
<h2 class="anchored" data-anchor-id="research-questions">Research Questions</h2>
<p>To what extent do sleep patterns, along with other factors, correlate with a person’s job classification?</p>
<p>How accurately can a classification model predict a person’s job based on their sleep patterns and other relevant factors?</p>
<pre class="{ipython}"><code>import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score
from sklearn.decomposition import PCA

print("Libraries imported successfully!")

import os

file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'

# Check if the file exists
if os.path.exists(file_path):
    print("File exists, proceeding to load.")
    try:
        sleep = pd.read_csv(file_path)
        print("File loaded successfully.")
        print(sleep.head())  # Print the first few rows to confirm the data is loaded
    except Exception as e:
        print(f"An error occurred while loading the file: {e}")
else:
    print("File does not exist, please check the file path.")
    
sleep = pd.read_csv(file_path)
</code></pre>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

sleep.info()

sleep.describe()

# Select some columns that might have a correlation
numerical_data = sleep[['Age', 'Sleep Duration','Quality of Sleep','Physical Activity Level', 'Stress Level','Heart Rate', 'Daily Steps']]
correlation_matrix = numerical_data.corr()

# Generate the heatmap and use a new color sheme
ax = sns.heatmap(correlation_matrix, annot=True, cmap="PuOr");
fig = ax.get_figure()</code></pre>
<p><img src="figure7.png" class="img-fluid"></p>
</section>
<section id="correlation-of-numeric-variables" class="level2">
<h2 class="anchored" data-anchor-id="correlation-of-numeric-variables">Correlation of Numeric Variables</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Select some columns that might have a correlation
numerical_data = sleep[['Age', 'Sleep Duration','Quality of Sleep','Physical Activity Level', 'Stress Level','Heart Rate', 'Daily Steps']]
correlation_matrix = numerical_data.corr()

# Generate the heatmap and use a new color sheme
plt.figure(figsize=(10, 8))
ax = sns.heatmap(correlation_matrix, annot=True, cmap="PuOr");
fig = ax.get_figure()

plt.title('Correlation Matrix of Selected Features')
plt.show()</code></pre>
<p><img src="figure_1.png" class="img-fluid"></p>
</section>
<section id="occupation-by-the-numbers" class="level2">
<h2 class="anchored" data-anchor-id="occupation-by-the-numbers">Occupation By The Numbers</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)
sleep.Occupation.unique()

sleep.groupby('Occupation').agg(
    num_occ=('Occupation', 'size')
).reset_index()</code></pre>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)
def occupation_group(row):
    if row["Occupation"] in ["Salesperson", "Sales Representative", "Manager"]:
        return "Sales"
    elif row["Occupation"] in ["Software Engineer", "Scientist", "Accountant"]:
        return "STEM"
    elif row["Occupation"] in ["Doctor", "Nurse"]:
        return "Medical"
    else:
        return row["Occupation"]

sleep["Occupation_Group"] = sleep.apply(occupation_group, axis=1)</code></pre>
<p><img src="figure8.png" class="img-fluid"></p>
</section>
<section id="look-at-distribution-based-on-age" class="level2">
<h2 class="anchored" data-anchor-id="look-at-distribution-based-on-age">Look at distribution based on Age</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Look at the distribution based on Age
fig, ax = plt.subplots(figsize=(10, 5))
ax.hist(sleep['Age'], bins=15)
ax.set_title('Distribution of Ages')
ax.set_xlabel('Age')
ax.set_ylabel('Frequency')
plt.show()</code></pre>
<p><img src="Figure_2.png" class="img-fluid"></p>
</section>
<section id="stress-level" class="level2">
<h2 class="anchored" data-anchor-id="stress-level">Stress Level</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

sleep.groupby('Stress Level').agg(
    num_individuals=('Stress Level', 'size')
).reset_index()</code></pre>
</section>
<section id="sleep-duration" class="level2">
<h2 class="anchored" data-anchor-id="sleep-duration">Sleep Duration</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Look at the distribution based on Age
fig, ax = plt.subplots(figsize=(10, 5))
ax.hist(sleep['Sleep Duration'], bins=20)
ax.set_title('Distribution of Sleep Duration')
ax.set_xlabel('Sleep Duration')
ax.set_ylabel('Frequency')
plt.show()
#Figure out who is 8.5?</code></pre>
<p><img src="figure_3.png" class="img-fluid"></p>
</section>
<section id="quality-of-sleep" class="level2">
<h2 class="anchored" data-anchor-id="quality-of-sleep">Quality of Sleep</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

sleep.groupby('Quality of Sleep').agg(
    num_individuals=('Quality of Sleep', 'size')
).reset_index()</code></pre>
<p><img src="figure9.png" class="img-fluid"></p>
</section>
<section id="gender" class="level2">
<h2 class="anchored" data-anchor-id="gender">Gender</h2>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

sleep.groupby('Gender').agg(
    num_occ=('Gender', 'size')
).reset_index()</code></pre>
<p><img src="figure10.png" class="img-fluid"></p>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

grouped_data = sleep.groupby(['Gender', 'Occupation']).size().reset_index(name='n')

# Pivot the data to get 'Gender' as columns and 'Occupation' as index
pivot_data = grouped_data.pivot(index='Occupation', columns='Gender', values='n').fillna(0)

# Rename the columns and reset the index
pivot_data.columns.name = None
pivot_data = pivot_data.reset_index()

pivot_data</code></pre>
<p><img src="figure11.png" class="img-fluid"></p>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)
# Pivot the data to get 'Gender' as columns and 'Occupation' as index
grouped_data = sleep.groupby(['Stress Level', 'Occupation']).size().reset_index(name='n')
pivot_data = grouped_data.pivot(index='Occupation', columns='Stress Level', values='n').fillna(0)
pivot_data.columns.name = None
pivot_data = pivot_data.reset_index()

pivot_data
# Create the heatmap using seaborn
sns.heatmap(pivot_data.set_index('Occupation'), annot=True, cmap='YlGnBu', fmt='g')

# Set the title and labels
plt.title("Stress Level vs Occupation Heatmap")
plt.xlabel("Stress Level")
plt.ylabel("Occupation")

# Display the heatmap
plt.show()</code></pre>
<p><img src="figure_4.png" class="img-fluid"></p>
<pre class="{ipython}"><code>import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)
# Pivot the data to get 'Gender' as columns and 'Occupation' as index

grouped_data = sleep.groupby(['Quality of Sleep', 'Stress Level']).size().reset_index(name='Total Counts')


# Pivot the data to create a heatmap
pivot_data = grouped_data.pivot(index='Stress Level', columns='Quality of Sleep', values='Total Counts').fillna(0)

# Create the heatmap using seaborn
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_data, annot=True, cmap='YlGnBu', fmt='g')
plt.xlabel('Quality of Sleep')
plt.ylabel('Stress Level')
plt.title('Heatmap of Quality of Sleep vs. Stress Level')
plt.show()</code></pre>
<p><img src="figure_6.png" class="img-fluid"></p>
</section>
<section id="machine-learning" class="level2">
<h2 class="anchored" data-anchor-id="machine-learning">Machine Learning</h2>
<pre class="{ipython}"><code>import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, ConfusionMatrixDisplay
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
from sklearn.impute import SimpleImputer

# Load the dataset
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Separate features and target variable
x = sleep.drop(columns=['Person ID', 'Sleep Disorder', 'Blood Pressure'])
y = sleep['Sleep Disorder']

# Inspect the data for NaNs
print("Checking for NaNs in the dataset:")
print(x.isnull().sum())

# Handle missing values
# Impute numerical columns with mean
numerical_cols = x.select_dtypes(include=['float64', 'int64']).columns
imputer_num = SimpleImputer(strategy='mean')
x[numerical_cols] = imputer_num.fit_transform(x[numerical_cols])

# Impute categorical columns with most frequent value
categorical_cols = ['Gender', 'Occupation', 'BMI Category', 'Stress Level']
imputer_cat = SimpleImputer(strategy='most_frequent')
x[categorical_cols] = imputer_cat.fit_transform(x[categorical_cols])

# Recheck for any remaining NaN values
print("Rechecking for NaNs after imputation:")
print(x.isnull().sum())

# Encode categorical variables
label_encoder = LabelEncoder()
for col in categorical_cols:
    x[col] = label_encoder.fit_transform(x[col])

# Ensure there are no NaNs before proceeding
if x.isnull().values.any():
    raise ValueError("Data still contains NaN values after handling missing data.")

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

# One-hot encode the categorical columns
encoder = OneHotEncoder()
x_train_encoded = encoder.fit_transform(x_train[categorical_cols])
x_test_encoded = encoder.transform(x_test[categorical_cols])

# Combine the one-hot encoded features with other numerical features
x_train_final = np.hstack((x_train_encoded.toarray(), x_train.drop(columns=categorical_cols).values))
x_test_final = np.hstack((x_test_encoded.toarray(), x_test.drop(columns=categorical_cols).values))

# Fit the RandomForestClassifier and make predictions
rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier.fit(x_train_final, y_train)
y_pred = rf_classifier.predict(x_test_final)
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy of the random forest classifier:", accuracy)

# Display the confusion matrix
ConfusionMatrixDisplay.from_predictions(y_test, y_pred, labels=rf_classifier.classes_, display_labels=rf_classifier.classes_, cmap="YlGnBu")
plt.show()

</code></pre>
</section>
<section id="random-forrest-vs.-svm-classifier" class="level2">
<h2 class="anchored" data-anchor-id="random-forrest-vs.-svm-classifier">Random Forrest vs.&nbsp;SVM Classifier</h2>
<pre class="{ipython}"><code>import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.metrics import confusion_matrix
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import accuracy_score
from sklearn.preprocessing import LabelEncoder, OneHotEncoder

#Load the dataset
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Assuming 'sleep' is your DataFrame
x = sleep.drop(columns=['Person ID', 'Sleep Disorder', 'Blood Pressure'])
y = sleep['Sleep Disorder']

label_encoder = LabelEncoder()
categorical_cols = ['Gender', 'Occupation', 'BMI Category', 'Stress Level']
for col in categorical_cols:
    x[col] = label_encoder.fit_transform(x[col])

# One-hot encode the categorical columns (if needed)
encoder = OneHotEncoder()
x_encoded = encoder.fit_transform(x[categorical_cols])
x_final = np.hstack((x_encoded.toarray(), x.drop(columns=categorical_cols).values))

x_train, x_test, y_train, y_test = train_test_split(x_final, y, test_size=0.2, random_state=42)

# RandomForestClassifier
rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier.fit(x_train, y_train)
y_pred_rf = rf_classifier.predict(x_test)
accuracy_rf = accuracy_score(y_test, y_pred_rf)

# SVM Classifier
svm_classifier = SVC(kernel='linear', random_state=42)
svm_classifier.fit(x_train, y_train)
y_pred_svm = svm_classifier.predict(x_test)
accuracy_svm = accuracy_score(y_test, y_pred_svm)

print("Accuracy of the random forest classifier:", accuracy_rf)
print("Accuracy of the SVM classifier:", accuracy_svm)

ConfusionMatrixDisplay.from_predictions(y_test, y_pred_svm, display_labels=svm_classifier.classes_, cmap="YlGnBu")
plt.show()
</code></pre>
</section>
<section id="clustering" class="level2">
<h2 class="anchored" data-anchor-id="clustering">Clustering</h2>
<pre class="{ipython}"><code>from sklearn.preprocessing import OneHotEncoder, LabelEncoder, StandardScaler
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import pandas as pd

# Load the dataset
file_path = '/Users/Shared/Python/Sleep_health_and_lifestyle_dataset.csv'
sleep = pd.read_csv(file_path)

# Assuming 'sleep' is your DataFrame
# Split 'Blood Pressure' into 'Systolic' and 'Diastolic'
bp_split = sleep['Blood Pressure'].str.split('/', expand=True)
sleep['Systolic'] = pd.to_numeric(bp_split[0], errors='coerce')
sleep['Diastolic'] = pd.to_numeric(bp_split[1], errors='coerce')

# Drop the original 'Blood Pressure' column
x = sleep.drop(columns=['Person ID', 'Sleep Disorder', 'Gender', 'Blood Pressure'])
y = sleep['Sleep Disorder']

# Encode categorical variables
label_encoder = LabelEncoder()
categorical_cols = ['Occupation', 'BMI Category', 'Stress Level']
for col in categorical_cols:
    x[col] = label_encoder.fit_transform(x[col])

# Normalize the data
scaler = StandardScaler()
x_scaled = scaler.fit_transform(x)

# Perform K-means clustering
kmeans = KMeans(n_clusters=3, random_state=42)
kmeans_clusters = kmeans.fit_predict(x_scaled)

# Visualize the clusters
plt.scatter(x_scaled[:, 0], x_scaled[:, 1], c=kmeans_clusters, cmap='viridis', marker='o')
plt.xlabel('Feature 1')
plt.ylabel('Feature 2')
plt.title('K-means Clustering')
plt.show()

</code></pre>
<p><img src="figure_5.png" class="img-fluid"> ## Summary</p>
<p>This study delved into the relationship between sleep patterns, job classification, and other relevant factors to accurately predict job roles. By leveraging data analytics and machine learning techniques, we aimed to optimize workforce planning and develop personalized workplace strategies.</p>
<p>Key Insights</p>
<p>1.<strong>Correlation Analysis:</strong> Identified significant correlations between sleep duration, stress levels, and job classifications.</p>
<p>2.<strong>Distribution Analysis:</strong> Provided insights into the age and sleep duration distributions among different occupations.</p>
<p>3.<strong>Heatmaps</strong> Highlighted the relationship between stress levels and sleep quality across various occupations.</p>
<p>4.<strong>Machine Learning Models:</strong> Demonstrated that Random Forest and SVM classifiers could predict sleep disorders with high accuracy based on sleep-related data.</p>
<p>5.<strong>Clustering:</strong> K-means clustering revealed distinct groups within the data, indicating potential subgroups with unique sleep and job characteristics.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<p>1.<strong>Predictive Power:</strong> Sleep patterns, stress levels, and demographic data can effectively predict job classifications.</p>
<p>2.<strong>Model Performance:</strong> Random Forest classifiers showed promising accuracy, outperforming SVM in this context.</p>
<p>3.<strong>Workforce Planning:</strong> These insights can inform HR strategies, promoting better sleep health and productivity among employees.</p>
<p>4.<strong>Future Research:</strong> Further studies can explore additional factors such as dietary habits and mental health for a comprehensive analysis.</p>
<p>This comprehensive analysis underscores the critical role of sleep patterns in predicting job classifications, offering valuable insights for both researchers and HR professionals. By integrating these findings into workforce management strategies, organizations can foster a healthier, more productive work environment.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>